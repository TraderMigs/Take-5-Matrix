import { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { useToast } from "@/hooks/use-toast";
import { Download, FileText, FileType, FileSpreadsheet, File } from "lucide-react";

interface DiaryEntry {
  id: number;
  title: string;
  content: string;
  mood?: string;
  createdAt: string;
  images?: string[];
}

interface DiaryEntryDownloadModalProps {
  isOpen: boolean;
  onClose: () => void;
  entry: DiaryEntry | null;
  userName?: string;
}

const downloadOptions = [
  {
    id: 'pdf',
    title: 'PDF Document',
    description: 'Professional format with formatting preserved',
    icon: FileText,
    color: 'bg-red-600 hover:bg-red-700'
  },
  {
    id: 'docx',
    title: 'Word Document',
    description: 'Editable Microsoft Word format (.docx)',
    icon: FileType,
    color: 'bg-blue-600 hover:bg-blue-700'
  },
  {
    id: 'txt',
    title: 'Plain Text',
    description: 'Simple text file without formatting',
    icon: File,
    color: 'bg-gray-600 hover:bg-gray-700'
  },
  {
    id: 'html',
    title: 'Web Page',
    description: 'HTML format for web viewing',
    icon: FileSpreadsheet,
    color: 'bg-orange-600 hover:bg-orange-700'
  }
];

export default function DiaryEntryDownloadModal({ isOpen, onClose, entry, userName }: DiaryEntryDownloadModalProps) {
  const [isDownloading, setIsDownloading] = useState(false);
  const { toast } = useToast();

  const handleDownload = async (format: string) => {
    if (!entry) {
      toast({
        title: "No entry selected",
        description: "Please select a diary entry to download.",
        variant: "destructive",
      });
      return;
    }

    setIsDownloading(true);
    
    try {
      await downloadEntry(entry, format, userName);
      
      toast({
        title: "Download successful",
        description: `Your diary entry has been downloaded as ${format.toUpperCase()}.`,
        className: "bg-green-800 border-green-700 text-white",
      });
      
      onClose();
    } catch (error) {
      console.error('Download error:', error);
      toast({
        title: "Download failed",
        description: "There was an error downloading your entry. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsDownloading(false);
    }
  };

  const downloadEntry = async (entry: DiaryEntry, format: string, userName?: string) => {
    const date = new Date(entry.createdAt).toLocaleDateString();
    const filename = `${(entry.title || 'untitled').replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${date.replace(/\//g, '-')}`;

    switch (format) {
      case 'pdf':
        await downloadAsPDF(entry, filename, userName);
        break;
      case 'docx':
        await downloadAsDocx(entry, filename, userName);
        break;
      case 'txt':
        downloadAsText(entry, filename);
        break;
      case 'html':
        downloadAsHTML(entry, filename, userName);
        break;
      default:
        throw new Error('Unsupported format');
    }
  };

  const downloadAsPDF = async (entry: DiaryEntry, filename: string, userName?: string) => {
    // Import jsPDF dynamically
    const { jsPDF } = await import('jspdf');
    
    const pdf = new jsPDF();
    const pageWidth = pdf.internal.pageSize.width;
    const margin = 20;
    const maxWidth = pageWidth - 2 * margin;
    
    // Title
    pdf.setFontSize(18);
    pdf.setFont(undefined, 'bold');
    pdf.text(entry.title || 'Untitled Entry', margin, 30);
    
    // Date and mood
    pdf.setFontSize(12);
    pdf.setFont(undefined, 'normal');
    const date = new Date(entry.createdAt).toLocaleDateString();
    pdf.text(`Date: ${date}`, margin, 45);
    
    if (entry.mood) {
      pdf.text(`Mood: ${entry.mood}`, margin, 55);
    }
    
    // Content
    pdf.setFontSize(11);
    const lines = pdf.splitTextToSize(entry.content, maxWidth);
    pdf.text(lines, margin, entry.mood ? 70 : 60);
    
    // Footer
    if (userName) {
      const footerY = pdf.internal.pageSize.height - 20;
      pdf.setFontSize(8);
      pdf.setTextColor(128);
      pdf.text(`Generated by Take 5 for ${userName}`, margin, footerY);
    }
    
    pdf.save(`${filename}.pdf`);
  };

  const downloadAsDocx = async (entry: DiaryEntry, filename: string, userName?: string) => {
    // Create a simple DOCX-like structure using HTML
    const date = new Date(entry.createdAt).toLocaleDateString();
    
    let content = `
      <html>
        <head>
          <meta charset="utf-8">
          <title>${entry.title}</title>
        </head>
        <body style="font-family: Arial, sans-serif; margin: 40px;">
          <h1>${entry.title || 'Untitled Entry'}</h1>
          <p><strong>Date:</strong> ${date}</p>
          ${entry.mood ? `<p><strong>Mood:</strong> ${entry.mood}</p>` : ''}
          <hr>
          <div style="white-space: pre-wrap; line-height: 1.6;">${entry.content}</div>
          ${userName ? `<br><br><hr><p style="font-size: 12px; color: #666;">Generated by Take 5 for ${userName}</p>` : ''}
        </body>
      </html>
    `;
    
    const blob = new Blob([content], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}.docx`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const downloadAsText = (entry: DiaryEntry, filename: string) => {
    const date = new Date(entry.createdAt).toLocaleDateString();
    
    let content = `${entry.title || 'Untitled Entry'}\n`;
    content += `Date: ${date}\n`;
    if (entry.mood) {
      content += `Mood: ${entry.mood}\n`;
    }
    content += `\n${'-'.repeat(50)}\n\n`;
    content += entry.content;
    
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const downloadAsHTML = (entry: DiaryEntry, filename: string, userName?: string) => {
    const date = new Date(entry.createdAt).toLocaleDateString();
    
    const content = `
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>${entry.title}</title>
          <style>
            body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 40px; line-height: 1.6; }
            h1 { color: #333; border-bottom: 2px solid #ddd; padding-bottom: 10px; }
            .meta { color: #666; font-size: 14px; margin-bottom: 20px; }
            .content { white-space: pre-wrap; }
            .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; font-size: 12px; color: #999; }
          </style>
        </head>
        <body>
          <h1>${entry.title || 'Untitled Entry'}</h1>
          <div class="meta">
            <p><strong>Date:</strong> ${date}</p>
            ${entry.mood ? `<p><strong>Mood:</strong> ${entry.mood}</p>` : ''}
          </div>
          <div class="content">${entry.content}</div>
          ${userName ? `<div class="footer">Generated by Take 5 for ${userName}</div>` : ''}
        </body>
      </html>
    `;
    
    const blob = new Blob([content], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}.html`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-sm mx-auto bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
        <DialogHeader>
          <DialogTitle className="text-lg font-bold text-black dark:text-white flex items-center gap-2">
            <Download className="w-4 h-4" />
            Download Entry
          </DialogTitle>
        </DialogHeader>
        
        <div className="space-y-3 mt-3">
          {entry && (
            <div className="bg-gray-50 dark:bg-gray-700 p-2 rounded-lg">
              <h3 className="font-medium text-black dark:text-white text-sm">{entry.title || 'Untitled Entry'}</h3>
              <p className="text-xs text-gray-600 dark:text-gray-400">
                {new Date(entry.createdAt).toLocaleDateString()}
              </p>
            </div>
          )}
          
          <p className="text-xs text-gray-600 dark:text-gray-400">
            Choose your preferred download format:
          </p>
          
          <div className="space-y-2">
            {downloadOptions.map((option) => {
              const IconComponent = option.icon;
              return (
                <Button
                  key={option.id}
                  onClick={() => handleDownload(option.id)}
                  disabled={isDownloading}
                  className={`w-full ${option.color} text-white p-3 h-auto justify-start`}
                >
                  <div className="flex items-center gap-2">
                    <IconComponent className="w-4 h-4" />
                    <div className="text-left">
                      <div className="font-medium text-sm">{option.title}</div>
                      <div className="text-xs opacity-90">{option.description}</div>
                    </div>
                  </div>
                </Button>
              );
            })}
          </div>
          
          <Button
            onClick={onClose}
            variant="outline"
            className="w-full mt-2"
            disabled={isDownloading}
          >
            Cancel
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}